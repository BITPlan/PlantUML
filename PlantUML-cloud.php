<?php
/**
 * Parser hook extension adds a <uml> tag to wiki markup for rendering UML
 * diagrams within a wiki page using PlantUML.
 *
 * Cloud version : this version does not require PlantUML to be installed
 * It uses http://www.plantuml.com services to build diagrams
 * (only at creation : they are stored locally afterwards).
 *
 * Installation:
 *  1. Create a subdirectory PlantUML in your extensions folder.
 *  2. Copy this file and the plantuml.jar file into this folder.
 *  3. Adapt the getUploadPath and getUploadDirectory to your preference
 *     if you want these different from MediaWiki's standard settings.
 *  4. Put the following line near the end of your LocalSettings.php in
 *     MediaWiki's root folder to include the extension:
 *
 * require_once('extensions/PlantUML/PlantUML-cloud.php');
 *
 *  5. Enjoy!
 *
 * CHANGES:
 *   Version 0.1: Roques, A.
 *     - First version.
 *   Version 0.2:  Kersten, Pieter J., May 6, 2011
 *     - Changed code and comments to "classic" style.
 */
 
/**
 * You can change the result of the getUploadDirectory() and getUploadPath()
 * if you want to put generated images somewhere else.
 * Be default, it is in the upload directory.
 */
function getUploadDirectory() {
    global $wgUploadDirectory;
    return $wgUploadDirectory;
}
 
function getUploadPath() {
    global $wgUploadPath;
    return $wgUploadPath;
}
 
 
// Make sure we are being called properly
if( !defined( 'MEDIAWIKI' ) ) {
    echo( "This file is an extension to the MediaWiki software and cannot be used standalone.\n" );
    die( -1 );
}
 
//Avoid unstubbing $wgParser too early on modern (1.12+) MW versions, as per r35980
if ( defined( 'MW_SUPPORTS_PARSERFIRSTCALLINIT' ) ) {
    $wgHooks['ParserFirstCallInit'][] = 'wfPlantUMLExtension';
    $wgHooks['ArticleSave'][] = 'cleanImages';
} else {
    $wgExtensionFunctions[] = 'wfPlantUMLExtension';
}
 
$wgExtensionCredits['parserhook'][] = array(
    'name' => 'UML',
    'version' => '0.2',
    'author' => 'Roques A.',
    'url' => 'http://www.mediawiki.org/wiki/Extension:PlantUML',
    'description' => 'Renders a UML model from text using PlantUML.'
);
 
/**
 * Clean the image folder when required
 */
function cleanImages() {
    $title_hash = md5(getPageTitle());
    $path = getUploadDirectory()."/uml-".$title_hash."-*.png";
    $files = glob($path);
    foreach ($files as $filename) {
        unlink($filename);
    }
    return true;
}
 
/** 
 * Register this extension with the WikiText parser.
 * The first parameter is the name of the new tag. In this case the
 * tag <uml> ... </uml>. The second parameter is the callback function
 * for processing the text between the tags.
 */
function wfPlantUMLExtension() {
    global $wgParser;
    $wgParser->setHook( 'uml', 'renderUML' );
    return true;
}
 
/**
 * Renders a PlantUML model by the using the following method:
 *  - Encode the source like explained here: http://plantuml.sourceforge.net/codephp.html
 *  - Use as filename a md5 hash of the uml source
 *  - Copy the image generated by http://www.plantuml.com in the upload directory
 *
 * @param string PlantUML model
 * @returns true if the picture has been successfully saved to the picture
 *          cache directory
 */
function renderPlantUML($PlantUML_Source) {
    global $plantumlJar;
 
    $hash = md5($PlantUML_Source);
    $title_hash = md5(getPageTitle());
 
    // Build URL that describes the image
    $img = "http://www.plantuml.com/plantuml/img/"; 
    $img .= encodep($PlantUML_Source); 
 
    // Copy images into the local cache 
    $pngFile = getUploadDirectory()."/uml-".$title_hash."-".$hash.".png";
    copy($img, $pngFile);
 
    if (is_file($pngFile)) {
      return true;
    }
 
    return false;
}
 
/**
 * Tries to match the PlantUML given as argument against the cache. 
 * If the picture has not been rendered before, it'll
 * try to render the PlantUML and drop it in the picture cache directory.
 *
 * @param string model in been format
 * @returns the webserver based URL to a picture which contains the
 * requested PlantUML model. If anything fails, the resultvalue is false.
 */
function getImageURL($PlantUML_Source) {
    // Compute hash
    $title_hash = md5(getPageTitle());
    $formula_hash = md5($PlantUML_Source);
 
    $filename = 'uml-'.$title_hash."-".$formula_hash.".png";
    $full_path_filename = getUploadDirectory()."/".$filename;
 
    if (is_file($full_path_filename)) {
        return getUploadPath()."/".$filename;
    } else {
        if (renderPlantUML($PlantUML_Source)) {
            return getUploadPath()."/".$filename;
        } else {
            return false;
        }
    }
}
 
# The callback function for converting the input text to HTML output
function renderUML( $input, $argv ) {
    $url = getImageURL($input);
 
    if ($url == false) {
        $text = "[An error occured in PlantUML extension]";
    } else {
        $text = "<img src='$url'>";
    }
    return $text;
}
 
/**
 * Get a title for this page.
 * @returns title
 */
function getPageTitle() {
    global $wgArticle;
    global $wgTitle;
    // Retrieving the title of a page is not that easy
    if (empty($wgTitle)) {
        $title = $wgArticle->getTitle()->getText();
        return $title;
    }
    return $wgTitle;
}
 
// PHP API Client Code
// http://plantuml.sourceforge.net/codephp.html
function encodep($text) { 
     $data = mb_convert_encoding($text, 'UTF-8', mb_detect_encoding($text));
     $compressed = gzdeflate($data, 9); 
     return encode64($compressed); 
} 
 
function encode6bit($b) { 
     if ($b < 10) { 
          return chr(48 + $b); 
     } 
     $b -= 10; 
     if ($b < 26) { 
          return chr(65 + $b); 
     } 
     $b -= 26; 
     if ($b < 26) { 
          return chr(97 + $b); 
     } 
     $b -= 26; 
     if ($b == 0) { 
          return '-'; 
     } 
     if ($b == 1) { 
          return '_'; 
     } 
     return '?'; 
} 
 
function append3bytes($b1, $b2, $b3) { 
     $c1 = $b1 >> 2; 
     $c2 = (($b1 & 0x3) << 4) | ($b2 >> 4); 
     $c3 = (($b2 & 0xF) << 2) | ($b3 >> 6); 
     $c4 = $b3 & 0x3F; 
     $r = ""; 
     $r .= encode6bit($c1 & 0x3F); 
     $r .= encode6bit($c2 & 0x3F); 
     $r .= encode6bit($c3 & 0x3F); 
     $r .= encode6bit($c4 & 0x3F); 
     return $r; 
} 
 
function encode64($c) { 
     $str = ""; 
     $len = strlen($c); 
     for ($i = 0; $i < $len; $i+=3) { 
            if ($i+2==$len) { 
                  $str .= append3bytes(ord(substr($c, $i, 1)), ord(substr($c, $i+1, 1)), 0); 
            } else if ($i+1==$len) { 
                  $str .= append3bytes(ord(substr($c, $i, 1)), 0, 0); 
            } else { 
                  $str .= append3bytes(ord(substr($c, $i, 1)), ord(substr($c, $i+1, 1)), ord(substr($c, $i+2, 1)));
            } 
     } 
     return $str; 
}
?>
